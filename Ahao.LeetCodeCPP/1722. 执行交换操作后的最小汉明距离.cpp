#include<vector>

using namespace std;


/*
1722. 执行交换操作后的最小汉明距离
给你两个整数数组 source 和 target ，长度都是 n 。还有一个数组 allowedSwaps ，其中每个 allowedSwaps[i] = [ai, bi] 表示你可以交换数组 source 中下标为 ai 和 bi（下标从 0 开始）的两个元素。注意，你可以按 任意 顺序 多次 交换一对特定下标指向的元素。

相同长度的两个数组 source 和 target 间的 汉明距离 是元素不同的下标数量。形式上，其值等于满足 source[i] != target[i] （下标从 0 开始）的下标 i（0 <= i <= n-1）的数量。

在对数组 source 执行 任意 数量的交换操作后，返回 source 和 target 间的 最小汉明距离 。
*/
class Solution {
public:
	vector<int> p;

	int find(int x)
	{
		if (p[x] != x) p[x] = find(p[x]);
		return p[x];
	}

	int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {
		int n = source.size();
		for (int i = 0; i < n; i++) p.push_back(i);
		for (auto& t : allowedSwaps) p[find(t[0])] = find(t[1]);

		vector<unordered_multiset<int>> hash(n);
		for (int i = 0; i < n; i++)
		{
			hash[find(i)].insert(source[i]);
		}
		int res = 0;
		for (int i = 0; i < n; i++)
		{
			auto& h = hash[find(i)];
			if (h.count(target[i])) h.erase(h.find(target[i]));
			else res++;
		}
		return res;
	}
};

